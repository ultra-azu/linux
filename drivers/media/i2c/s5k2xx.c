// SPDX-License-Identifier: GPL-2.0
// Copyright (c) 2019 Intel Corporation.

#include <asm/unaligned.h>
#include <linux/acpi.h>
#include <linux/clk.h>
#include <linux/delay.h>
#include <linux/of_device.h>
#include <linux/gpio/consumer.h>
#include <linux/i2c.h>
#include <linux/module.h>
#include <linux/pm_runtime.h>
#include <linux/regulator/consumer.h>
#include <media/v4l2-ctrls.h>
#include <media/v4l2-device.h>
#include <media/v4l2-fwnode.h>

#define S5K2XX_REG_VALUE_08BIT		1
#define S5K2XX_REG_VALUE_16BIT		2
#define S5K2XX_REG_VALUE_24BIT		3

#define S5K2XX_MCLK			24000000
#define S5K2XX_DATA_LANES			4

#define S5K2XX_REG_CHIP_ID		0x0000
#define S5K2XX_CHIP_ID			0x2106

#define S5K2XX_REG_MODE_SELECT		0x0100
#define S5K2XX_MODE_STANDBY		0x0000
#define S5K2XX_MODE_STREAMING		0x0100

/* vertical-timings from sensor */
#define S5K2XX_REG_FLL			0x0340
#define S5K2XX_FLL_30FPS			0x0e1a
#define S5K2XX_FLL_30FPS_MIN		0x0e1a
#define S5K2XX_FLL_MAX			0x7fff

/* horizontal-timings from sensor */
#define S5K2XX_REG_LLP			0x0342

/* Exposure controls from sensor */
#define S5K2XX_REG_EXPOSURE		0x0202
#define S5K2XX_EXPOSURE_MIN		6
#define S5K2XX_EXPOSURE_MAX_MARGIN	2
#define S5K2XX_EXPOSURE_STEP		1

/* Analog gain controls from sensor */
#define S5K2XX_REG_ANALOG_GAIN		0x0204
#define S5K2XX_ANAL_GAIN_MIN		0
#define S5K2XX_ANAL_GAIN_MAX		255
#define S5K2XX_ANAL_GAIN_STEP		1

/* Digital gain controls from sensor */
#define S5K2XX_REG_DIG_GAIN		0x020e
#define S5K2XX_DGTL_GAIN_MIN		0
#define S5K2XX_DGTL_GAIN_MAX		2048
#define S5K2XX_DGTL_GAIN_STEP		1
#define S5K2XX_DGTL_GAIN_DEFAULT		256

static const char * const s5k2xx_supply_names[] = { "avdd", "dvdd", "vio", "aux" };

#define S5K2XX_NUM_SUPPLIES		ARRAY_SIZE(s5k2xx_supply_names)

struct s5k2xx_reg {
	u16 address;
	u16 val;
};

struct s5k2xx_reg_list {
	u32 num_regs;
	const struct s5k2xx_reg *regs;
};

struct s5k2xx_mode {
	/* Frame width in pixels */
	u32 width;

	/* Frame height in pixels */
	u32 height;

	/* Horizontal timining size */
	u32 llp;

	/* Default vertical timining size */
	u32 fll_def;

	/* Min vertical timining size */
	u32 fll_min;

	/* Refresh rate */
	u32 fps;

	u32 pixel_rate;

	/* Sensor register settings for this resolution */
	const struct s5k2xx_reg_list reg_list;
};

struct s5k2xx_data {
	const char *name;
	u32 chip_id;
	const struct s5k2xx_reg_list reg_init;
	const struct s5k2xx_mode *modes;
	size_t num_modes;
};

#define to_s5k2(_sd) container_of(_sd, struct s5k2xx, sd)

//SENSOR_INITIALIZATION
static const struct s5k2xx_reg s5k2p6_init[] = {
	{ 0xfcfc, 0x4000 }, { 0x6028, 0x2000 }, { 0x0100, 0x0000 }, { 0x6214, 0x7971 },
	{ 0x6218, 0x7150 }, { 0xf43a, 0x000c }, { 0xf470, 0x000d }, { 0x602a, 0x1c50 },
	{ 0x6f12, 0x15ff }, { 0x3092, 0x0000 }, { 0x3088, 0x0101 }, { 0x602a, 0x13ce },
	{ 0x6f12, 0x0000 }, { 0x6f12, 0x0000 }, { 0x6f12, 0x0000 }, { 0x6f12, 0x0000 },
	{ 0x6f12, 0x0004 }, { 0x6f12, 0x0004 }, { 0x6f12, 0x0004 }, { 0x6f12, 0x0004 },
	{ 0x602a, 0x196c }, { 0x6f12, 0x8010 }, { 0x31d2, 0x0220 }, { 0x602a, 0x195e },
	{ 0x6f12, 0x0001 }, { 0x3816, 0x0140 }, { 0x3818, 0x0140 }, { 0x3854, 0x0008 },
	{ 0x3856, 0x0008 }, { 0x3858, 0x0008 }, { 0x385a, 0x0008 }, { 0xf440, 0x002f },
	{ 0x319c, 0x0130 }, { 0x602a, 0x1266 }, { 0x6f12, 0x0001 }, { 0x6f12, 0x0000 },
	{ 0x30d4, 0x0001 }, { 0x30d6, 0x002b }, { 0xb138, 0x0000 }, { 0x0344, 0x0018 },
	{ 0x0348, 0x1217 }, { 0x0380, 0x0001 }, { 0x0382, 0x0001 }, { 0x0384, 0x0001 },
	{ 0x0408, 0x0000 }, { 0x040a, 0x0000 }, { 0x0136, 0x1800 }, { 0x0300, 0x0003 },
	{ 0x0302, 0x0001 }, { 0x0304, 0x0006 }, { 0x030c, 0x0004 }, { 0x300a, 0x0000 },
	{ 0x0200, 0x0200 }, { 0x0204, 0x0080 }, { 0x37c0, 0x0002 }, { 0x37c2, 0x0103 },
	{ 0x3004, 0x0003 }, { 0x0114, 0x0300 }, { 0x304c, 0x0000 }, { 0x3ac4, 0x0100 },
	{ 0x3e04, 0x0100 }, { 0x3b02, 0x000f }, { 0x3b34, 0x0000 }, { 0x3ad0, 0x0066 },
	{ 0x3b0c, 0x0000 }, { 0x3b3e, 0x001e }, { 0x3ada, 0x0085 }, { 0x3b16, 0x000f },
	{ 0x3b48, 0x0046 }, { 0x3ae4, 0x00ad }, { 0x3b20, 0xffe2 }, { 0x3b52, 0x0000 },
	{ 0x3aee, 0x0085 }, { 0x3e0e, 0x0fef }, { 0x3e18, 0x1010 }, { 0x3e22, 0x1018 },
	{ 0x6214, 0x7970 },
};

static const struct s5k2xx_reg s5k2p6_mode_4608x3456_regs[] = {
	{ 0xfcfc, 0x4000 }, { 0x6028, 0x2000 }, { 0x6214, 0x7971 }, { 0x6218, 0x7150 },
	{ 0x30ce, 0x0000 }, { 0x37f6, 0x0021 }, { 0x3198, 0x0007 }, { 0x319a, 0x0100 },
	{ 0x3056, 0x0100 }, { 0x602a, 0x1bb0 }, { 0x6f12, 0x0000 }, { 0x0b0e, 0x0100 },
	{ 0x30d8, 0x0100 }, { 0x31b0, 0x0008 }, { 0x0340, 0x0e1a }, { 0x0342, 0x1428 },
	{ 0x0346, 0x0010 }, { 0x034a, 0x0d8f }, { 0x034c, 0x1200 }, { 0x034e, 0x0d80 },
	{ 0x0900, 0x0011 }, { 0x0386, 0x0001 }, { 0x0400, 0x0000 }, { 0x0404, 0x0000 },
	{ 0x0306, 0x0069 }, { 0x1130, 0x440c }, { 0x030e, 0x0078 }, { 0x0202, 0x0e10 },
	{ 0x021e, 0x0e10 }, { 0x0216, 0x0000 }, { 0x6214, 0x7970 },
};

static const struct s5k2xx_reg s5k2p6_mode_1152x656_regs[] = {
	{ 0xfcfc, 0x4000 }, { 0x6028, 0x2000 }, { 0x6214, 0x7971 }, { 0x6218, 0x7150 },
	{ 0x30ce, 0x0040 }, { 0x37f6, 0x0001 }, { 0x3198, 0x00cc }, { 0x319a, 0x0000 },
	{ 0x3056, 0x0000 }, { 0x602a, 0x1bb0 }, { 0x6f12, 0x0100 }, { 0x0b0e, 0x0100 },
	{ 0x30d8, 0x0000 }, { 0x31b0, 0x0002 }, { 0x0340, 0x039c }, { 0x0342, 0x1448 },
	{ 0x0346, 0x01b0 }, { 0x034a, 0x0bef }, { 0x034c, 0x0480 }, { 0x034e, 0x0290 },
	{ 0x0900, 0x0114 }, { 0x0386, 0x0007 }, { 0x0400, 0x0001 }, { 0x0404, 0x0040 },
	{ 0x0306, 0x006c }, { 0x1130, 0x4411 }, { 0x030e, 0x0071 }, { 0x0202, 0x038e },
	{ 0x021e, 0x038e }, { 0x0216, 0x0000 }, { 0x6214, 0x7970 },
};

static const struct s5k2xx_mode s5k2p6_modes[] = {
	{
		.width = 4608,
		.height = 3456,
		.fps = 30,
		.fll_def = 3610,
		.fll_min = 3610,
		.llp = 5160,
		.pixel_rate = 620000000,
		.reg_list = {
			.num_regs = ARRAY_SIZE(s5k2p6_mode_4608x3456_regs),
			.regs = s5k2p6_mode_4608x3456_regs,
		},
	}, {
		.width = 1152,
		.height = 656,
		.fps = 120,
		.fll_def = 924,
		.fll_min = 924,
		.llp = 5192,
		.pixel_rate = 600000000,
		.reg_list = {
			.num_regs = ARRAY_SIZE(s5k2p6_mode_1152x656_regs),
			.regs = s5k2p6_mode_1152x656_regs,
		},
	},
};

static struct s5k2xx_data s5k2p6sx_data = {
	.name = "s5k2p6sx",
	.chip_id = 0x2106,
	.reg_init = {
		.regs = s5k2p6_init,
		.num_regs = ARRAY_SIZE(s5k2p6_init),
	},
	.modes = s5k2p6_modes,
	.num_modes = ARRAY_SIZE(s5k2p6_modes),
};

static const struct s5k2xx_reg s5k2x7_init[] = {
	{ 0xfcfc, 0x4000 }, { 0x6000, 0x0085 }, { 0x6214, 0x7971 }, { 0x6218, 0x7150 },
	{ 0x6000, 0x0005 }, { 0xfcfc, 0x2000 }, { 0x004a, 0x0001 }, { 0x00ea, 0xff08 },
	{ 0x00f6, 0x1000 }, { 0x00f8, 0x4000 }, { 0x00fa, 0x8000 }, { 0x00fc, 0xc000 },
	{ 0x00fe, 0xffff }, { 0x02f4, 0x0000 }, { 0x02f6, 0x0000 }, { 0x02f8, 0x0032 },
	{ 0x02fa, 0x0050 }, { 0x02fc, 0x0050 }, { 0x02fe, 0x00c8 }, { 0x0300, 0x00c8 },
	{ 0x0302, 0x0001 }, { 0x0304, 0x0118 }, { 0x0306, 0x0030 }, { 0x0308, 0x0028 },
	{ 0x030a, 0x0028 }, { 0x030c, 0x0050 }, { 0x030e, 0x00b4 }, { 0x0310, 0x00b4 },
	{ 0x0312, 0x00b4 }, { 0x0314, 0x00c8 }, { 0x0316, 0x00fa }, { 0x0318, 0x00fa },
	{ 0x031a, 0x012c }, { 0x031c, 0x0001 }, { 0x031e, 0x0028 }, { 0x0320, 0x0050 },
	{ 0x0322, 0x0000 }, { 0x0324, 0x0000 }, { 0x0326, 0x0025 }, { 0x0328, 0x003c },
	{ 0x032a, 0x003c }, { 0x032c, 0x0096 }, { 0x032e, 0x0096 }, { 0x0330, 0x0001 },
	{ 0x0332, 0x015b }, { 0x0334, 0x0035 }, { 0x0336, 0x0021 }, { 0x0338, 0x0021 },
	{ 0x033a, 0x0043 }, { 0x033c, 0x0096 }, { 0x033e, 0x0096 }, { 0x0340, 0x0096 },
	{ 0x0342, 0x00a7 }, { 0x0344, 0x00d0 }, { 0x0346, 0x00d0 }, { 0x0348, 0x00fa },
	{ 0x034a, 0x0001 }, { 0x034c, 0x0028 }, { 0x034e, 0x0050 }, { 0x0350, 0x0000 },
	{ 0x0352, 0x0000 }, { 0x0354, 0x0019 }, { 0x0356, 0x0028 }, { 0x0358, 0x0028 },
	{ 0x035a, 0x0064 }, { 0x035c, 0x0064 }, { 0x035e, 0x0001 }, { 0x0360, 0x019d },
	{ 0x0362, 0x0039 }, { 0x0364, 0x001b }, { 0x0366, 0x001b }, { 0x0368, 0x0035 },
	{ 0x036a, 0x0078 }, { 0x036c, 0x0078 }, { 0x036e, 0x0078 }, { 0x0370, 0x0085 },
	{ 0x0372, 0x00a7 }, { 0x0374, 0x00a7 }, { 0x0376, 0x00c8 }, { 0x0378, 0x0001 },
	{ 0x037a, 0x0028 }, { 0x037c, 0x0050 }, { 0x1360, 0x0000 }, { 0x19c8, 0x0200 },
	{ 0x1ba0, 0x0030 }, { 0x1ba2, 0x0081 }, { 0x1bde, 0x0001 }, { 0x1c04, 0x0a01 },
	{ 0x1c06, 0x0250 }, { 0x1c08, 0x8060 }, { 0x1c8a, 0x0011 }, { 0x1c8c, 0x1010 },
	{ 0x1c92, 0x7700 }, { 0x20c0, 0x0000 }, { 0x3df4, 0x0000 }, { 0x3df6, 0x0000 },
	{ 0x3df8, 0x0000 }, { 0x3dfa, 0x0000 }, { 0x3dfc, 0x0000 }, { 0x3dfe, 0x0000 },
	{ 0x3e00, 0x0449 }, { 0x3e02, 0x0348 }, { 0x3e04, 0x044a }, { 0x3e06, 0x0860 },
	{ 0x3e08, 0x101a }, { 0x3e0a, 0x8880 }, { 0x3e0c, 0x00f0 }, { 0x3e0e, 0x5eba },
	{ 0x3e10, 0x2000 }, { 0x3e12, 0x44f4 }, { 0x3e14, 0x2000 }, { 0x3e16, 0x3280 },
	{ 0x3e18, 0x2000 }, { 0x3e1a, 0x6500 }, { 0x3e1c, 0x0000 }, { 0x3e1e, 0x0000 },
	{ 0x3e20, 0x2de9 }, { 0x3e22, 0xf05f }, { 0x3e24, 0x9146 }, { 0x3e26, 0x0e46 },
	{ 0x3e28, 0x0446 }, { 0x3e2a, 0xdff8 }, { 0x3e2c, 0x08a4 }, { 0x3e2e, 0x30e0 },
	{ 0x3e30, 0x00f0 }, { 0x3e32, 0xbafa }, { 0x3e34, 0x8346 }, { 0x3e36, 0x4fea },
	{ 0x3e38, 0x4835 }, { 0x3e3a, 0x4046 }, { 0x3e3c, 0xfe4f }, { 0x3e3e, 0x0022 },
	{ 0x3e40, 0xb021 }, { 0x3e42, 0x05f5 }, { 0x3e44, 0x0055 }, { 0x3e46, 0x00f0 },
	{ 0x3e48, 0xb4fa }, { 0x3e4a, 0x388d }, { 0x3e4c, 0xf98c }, { 0x3e4e, 0x411a },
	{ 0x3e50, 0x4046 }, { 0x3e52, 0x00f0 }, { 0x3e54, 0xb3fa }, { 0x3e56, 0x788d },
	{ 0x3e58, 0xb989 }, { 0x3e5a, 0x411a }, { 0x3e5c, 0x5046 }, { 0x3e5e, 0xaaf8 },
	{ 0x3e60, 0x1a13 }, { 0x3e62, 0xb0f8 }, { 0x3e64, 0x1a13 }, { 0x3e66, 0x0029 },
	{ 0x3e68, 0xfbd1 }, { 0x3e6a, 0x7021 }, { 0x3e6c, 0xa0f8 }, { 0x3e6e, 0x0e13 },
	{ 0x3e70, 0xc4f3 }, { 0x3e72, 0x0c01 }, { 0x3e74, 0xae42 }, { 0x3e76, 0x00d2 },
	{ 0x3e78, 0x3546 }, { 0x3e7a, 0x2d1b }, { 0x3e7c, 0x2b46 }, { 0x3e7e, 0x4a46 },
	{ 0x3e80, 0x4046 }, { 0x3e82, 0x00f0 }, { 0x3e84, 0xa0fa }, { 0x3e86, 0x2c44 },
	{ 0x3e88, 0xa944 }, { 0x3e8a, 0x5946 }, { 0x3e8c, 0x4046 }, { 0x3e8e, 0x00f0 },
	{ 0x3e90, 0x9ffa }, { 0x3e92, 0x600b }, { 0x3e94, 0x5fea }, { 0x3e96, 0x0008 },
	{ 0x3e98, 0x01d1 }, { 0x3e9a, 0xb442 }, { 0x3e9c, 0xc8d3 }, { 0x3e9e, 0xbde8 },
	{ 0x3ea0, 0xf09f }, { 0x3ea2, 0x2de9 }, { 0x3ea4, 0xf041 }, { 0x3ea6, 0x8046 },
	{ 0x3ea8, 0xe448 }, { 0x3eaa, 0x1646 }, { 0x3eac, 0x0f46 }, { 0x3eae, 0x0068 },
	{ 0x3eb0, 0x0022 }, { 0x3eb2, 0x84b2 }, { 0x3eb4, 0x050c }, { 0x3eb6, 0x2146 },
	{ 0x3eb8, 0x2846 }, { 0x3eba, 0x00f0 }, { 0x3ebc, 0x8efa }, { 0x3ebe, 0x3246 },
	{ 0x3ec0, 0x3946 }, { 0x3ec2, 0x4046 }, { 0x3ec4, 0x00f0 }, { 0x3ec6, 0x8efa },
	{ 0x3ec8, 0xdd4b }, { 0x3eca, 0x16b9 }, { 0x3ecc, 0x0020 }, { 0x3ece, 0x83f8 },
	{ 0x3ed0, 0x8b00 }, { 0x3ed2, 0x33f8 }, { 0x3ed4, 0xf80f }, { 0x3ed6, 0x1989 },
	{ 0x3ed8, 0x1a7c }, { 0x3eda, 0x01fb }, { 0x3edc, 0x0200 }, { 0x3ede, 0x13f8 },
	{ 0x3ee0, 0x471c }, { 0x3ee2, 0x421a }, { 0x3ee4, 0xd749 }, { 0x3ee6, 0x8a80 },
	{ 0x3ee8, 0x5a88 }, { 0x3eea, 0x5e89 }, { 0x3eec, 0x9f7c }, { 0x3eee, 0x06fb },
	{ 0x3ef0, 0x0722 }, { 0x3ef2, 0x13f8 }, { 0x3ef4, 0x456c }, { 0x3ef6, 0x961b },
	{ 0x3ef8, 0xce80 }, { 0x3efa, 0x13f8 }, { 0x3efc, 0x3c3c }, { 0x3efe, 0x032b },
	{ 0x3f00, 0x03d1 }, { 0x3f02, 0x401e }, { 0x3f04, 0x8880 }, { 0x3f06, 0x521e },
	{ 0x3f08, 0xca80 }, { 0x3f0a, 0x2146 }, { 0x3f0c, 0x2846 }, { 0x3f0e, 0xbde8 },
	{ 0x3f10, 0xf041 }, { 0x3f12, 0x0122 }, { 0x3f14, 0x00f0 }, { 0x3f16, 0x61ba },
	{ 0x3f18, 0x2de9 }, { 0x3f1a, 0xf041 }, { 0x3f1c, 0x0646 }, { 0x3f1e, 0xc748 },
	{ 0x3f20, 0x0d46 }, { 0x3f22, 0x4268 }, { 0x3f24, 0x140c }, { 0x3f26, 0x97b2 },
	{ 0x3f28, 0x0022 }, { 0x3f2a, 0x3946 }, { 0x3f2c, 0x2046 }, { 0x3f2e, 0x00f0 },
	{ 0x3f30, 0x54fa }, { 0x3f32, 0xc348 }, { 0x3f34, 0x90f8 }, { 0x3f36, 0xbc10 },
	{ 0x3f38, 0x0329 }, { 0x3f3a, 0x07d0 }, { 0x3f3c, 0x90f8 }, { 0x3f3e, 0x0b11 },
	{ 0x3f40, 0x0129 }, { 0x3f42, 0x03d8 }, { 0x3f44, 0x90f8 }, { 0x3f46, 0x0901 },
	{ 0x3f48, 0x0128 }, { 0x3f4a, 0x01d9 }, { 0x3f4c, 0x0122 }, { 0x3f4e, 0x00e0 },
	{ 0x3f50, 0x0022 }, { 0x3f52, 0x2946 }, { 0x3f54, 0x3046 }, { 0x3f56, 0x00f0 },
	{ 0x3f58, 0x4afa }, { 0x3f5a, 0x3946 }, { 0x3f5c, 0x2046 }, { 0x3f5e, 0xbde8 },
	{ 0x3f60, 0xf041 }, { 0x3f62, 0x0122 }, { 0x3f64, 0x00f0 }, { 0x3f66, 0x39ba },
	{ 0x3f68, 0x2de9 }, { 0x3f6a, 0xf041 }, { 0x3f6c, 0x0546 }, { 0x3f6e, 0xb348 },
	{ 0x3f70, 0x0c46 }, { 0x3f72, 0x0022 }, { 0x3f74, 0x8168 }, { 0x3f76, 0x0e0c },
	{ 0x3f78, 0x8fb2 }, { 0x3f7a, 0x3946 }, { 0x3f7c, 0x3046 }, { 0x3f7e, 0x00f0 },
	{ 0x3f80, 0x2cfa }, { 0x3f82, 0x2146 }, { 0x3f84, 0x2846 }, { 0x3f86, 0x00f0 },
	{ 0x3f88, 0x37fa }, { 0x3f8a, 0x0122 }, { 0x3f8c, 0x3946 }, { 0x3f8e, 0x3046 },
	{ 0x3f90, 0x00f0 }, { 0x3f92, 0x23fa }, { 0x3f94, 0xac4a }, { 0x3f96, 0xab48 },
	{ 0x3f98, 0x02eb }, { 0x3f9a, 0x8505 }, { 0x3f9c, 0x0cb1 }, { 0x3f9e, 0xc088 },
	{ 0x3fa0, 0x0ae0 }, { 0x3fa2, 0x4088 }, { 0x3fa4, 0x08e0 }, { 0x3fa6, 0x1368 },
	{ 0x3fa8, 0x190c }, { 0x3faa, 0x9bb2 }, { 0x3fac, 0x44b1 }, { 0x3fae, 0x8142 },
	{ 0x3fb0, 0x04d9 }, { 0x3fb2, 0x43ea }, { 0x3fb4, 0x0041 }, { 0x3fb6, 0x02c2 },
	{ 0x3fb8, 0xaa42 }, { 0x3fba, 0xf4d1 }, { 0x3fbc, 0xbde8 }, { 0x3fbe, 0xf081 },
	{ 0x3fc0, 0x8142 }, { 0x3fc2, 0xf6d3 }, { 0x3fc4, 0xfae7 }, { 0x3fc6, 0x2de9 },
	{ 0x3fc8, 0xf041 }, { 0x3fca, 0x0646 }, { 0x3fcc, 0x9b48 }, { 0x3fce, 0x0d46 },
	{ 0x3fd0, 0xc268 }, { 0x3fd2, 0x140c }, { 0x3fd4, 0x97b2 }, { 0x3fd6, 0x0022 },
	{ 0x3fd8, 0x3946 }, { 0x3fda, 0x2046 }, { 0x3fdc, 0x00f0 }, { 0x3fde, 0xfdf9 },
	{ 0x3fe0, 0x2946 }, { 0x3fe2, 0x3046 }, { 0x3fe4, 0x00f0 }, { 0x3fe6, 0x0dfa },
	{ 0x3fe8, 0x0122 }, { 0x3fea, 0x3946 }, { 0x3fec, 0x2046 }, { 0x3fee, 0x00f0 },
	{ 0x3ff0, 0xf4f9 }, { 0x3ff2, 0x9648 }, { 0x3ff4, 0x964a }, { 0x3ff6, 0x30f8 },
	{ 0x3ff8, 0x1e1f }, { 0x3ffa, 0x1180 }, { 0x3ffc, 0x921c }, { 0x3ffe, 0x4188 },
	{ 0x4000, 0x1180 }, { 0x4002, 0x921c }, { 0x4004, 0x8188 }, { 0x4006, 0x1180 },
	{ 0x4008, 0x921c }, { 0x400a, 0xc188 }, { 0x400c, 0x1180 }, { 0x400e, 0x921c },
	{ 0x4010, 0x0189 }, { 0x4012, 0x1180 }, { 0x4014, 0x921c }, { 0x4016, 0x4189 },
	{ 0x4018, 0x1180 }, { 0x401a, 0x921c }, { 0x401c, 0x8189 }, { 0x401e, 0x1180 },
	{ 0x4020, 0x921c }, { 0x4022, 0xc189 }, { 0x4024, 0x1180 }, { 0x4026, 0x921c },
	{ 0x4028, 0x018a }, { 0x402a, 0x1180 }, { 0x402c, 0x921c }, { 0x402e, 0x418a },
	{ 0x4030, 0x1180 }, { 0x4032, 0x921c }, { 0x4034, 0x818a }, { 0x4036, 0x1180 },
	{ 0x4038, 0x921c }, { 0x403a, 0xc18a }, { 0x403c, 0x1180 }, { 0x403e, 0x921c },
	{ 0x4040, 0x018b }, { 0x4042, 0x1180 }, { 0x4044, 0x921c }, { 0x4046, 0x418b },
	{ 0x4048, 0x1180 }, { 0x404a, 0x921c }, { 0x404c, 0x818b }, { 0x404e, 0x1180 },
	{ 0x4050, 0x921c }, { 0x4052, 0xc18b }, { 0x4054, 0x1180 }, { 0x4056, 0x921c },
	{ 0x4058, 0x018c }, { 0x405a, 0x1180 }, { 0x405c, 0x921c }, { 0x405e, 0x418c },
	{ 0x4060, 0x1180 }, { 0x4062, 0x921c }, { 0x4064, 0x818c }, { 0x4066, 0x1180 },
	{ 0x4068, 0x911c }, { 0x406a, 0xc08c }, { 0x406c, 0x0880 }, { 0x406e, 0xa5e7 },
	{ 0x4070, 0x7cb5 }, { 0x4072, 0x0346 }, { 0x4074, 0x7748 }, { 0x4076, 0x448f },
	{ 0x4078, 0x058f }, { 0x407a, 0x4ff0 }, { 0x407c, 0x8040 }, { 0x407e, 0x8089 },
	{ 0x4080, 0xa0f5 }, { 0x4082, 0x2061 }, { 0x4084, 0x5139 }, { 0x4086, 0x02d1 },
	{ 0x4088, 0x0824 }, { 0x408a, 0x41f2 }, { 0x408c, 0x5815 }, { 0x408e, 0x6a46 },
	{ 0x4090, 0x01a9 }, { 0x4092, 0x1846 }, { 0x4094, 0x00f0 }, { 0x4096, 0xbaf9 },
	{ 0x4098, 0xdde9 }, { 0x409a, 0x0021 }, { 0x409c, 0x2046 }, { 0x409e, 0x00f0 },
	{ 0x40a0, 0xbaf9 }, { 0x40a2, 0x38b1 }, { 0x40a4, 0xdde9 }, { 0x40a6, 0x0021 },
	{ 0x40a8, 0x2846 }, { 0x40aa, 0x00f0 }, { 0x40ac, 0xb4f9 }, { 0x40ae, 0x08b1 },
	{ 0x40b0, 0x0120 }, { 0x40b2, 0x7cbd }, { 0x40b4, 0x0020 }, { 0x40b6, 0x7cbd },
	{ 0x40b8, 0xfeb5 }, { 0x40ba, 0x0446 }, { 0x40bc, 0x00f0 }, { 0x40be, 0xb0f9 },
	{ 0x40c0, 0x2046 }, { 0x40c2, 0x00f0 }, { 0x40c4, 0xb2f9 }, { 0x40c6, 0x4ff0 },
	{ 0x40c8, 0x8040 }, { 0x40ca, 0x8589 }, { 0x40cc, 0x94f8 }, { 0x40ce, 0x7700 },
	{ 0x40d0, 0x0190 }, { 0x40d2, 0x94f8 }, { 0x40d4, 0x7800 }, { 0x40d6, 0x0290 },
	{ 0x40d8, 0x94f8 }, { 0x40da, 0x3c01 }, { 0x40dc, 0x5d4e }, { 0x40de, 0x40f6 },
	{ 0x40e0, 0x5127 }, { 0x40e2, 0xd8b1 }, { 0x40e4, 0x718f }, { 0x40e6, 0xbd42 },
	{ 0x40e8, 0x04d1 }, { 0x40ea, 0x5b4a }, { 0x40ec, 0x0821 }, { 0x40ee, 0x0b20 },
	{ 0x40f0, 0xa2f8 }, { 0x40f2, 0x5001 }, { 0x40f4, 0x94f8 }, { 0x40f6, 0x2220 },
	{ 0x40f8, 0x4ff2 }, { 0x40fa, 0x5010 }, { 0x40fc, 0x82b3 }, { 0x40fe, 0x96f8 },
	{ 0x4100, 0x5420 }, { 0x4102, 0x6ab3 }, { 0x4104, 0x94f8 }, { 0x4106, 0x7620 },
	{ 0x4108, 0x042a }, { 0x410a, 0x21d0 }, { 0x410c, 0x94f8 }, { 0x410e, 0x3c31 },
	{ 0x4110, 0x21f0 }, { 0x4112, 0x0301 }, { 0x4114, 0x5a43 }, { 0x4116, 0x6b46 },
	{ 0x4118, 0x00f0 }, { 0x411a, 0x8cf9 }, { 0x411c, 0x94f8 }, { 0x411e, 0x3d01 },
	{ 0x4120, 0x48b3 }, { 0x4122, 0x94f8 }, { 0x4124, 0x7620 }, { 0x4126, 0x318f },
	{ 0x4128, 0x1346 }, { 0x412a, 0x4243 }, { 0x412c, 0xbd42 }, { 0x412e, 0x01d1 },
	{ 0x4130, 0x41f2 }, { 0x4132, 0x5811 }, { 0x4134, 0x94f8 }, { 0x4136, 0x2250 },
	{ 0x4138, 0x4ff2 }, { 0x413a, 0x6010 }, { 0x413c, 0x35b1 }, { 0x413e, 0x96f8 },
	{ 0x4140, 0x5450 }, { 0x4142, 0x1db1 }, { 0x4144, 0x042b }, { 0x4146, 0x21f0 },
	{ 0x4148, 0x0301 }, { 0x414a, 0x10d0 }, { 0x414c, 0x6b46 }, { 0x414e, 0x10e0 },
	{ 0x4150, 0x94f8 }, { 0x4152, 0x3c21 }, { 0x4154, 0x21f0 }, { 0x4156, 0x0301 },
	{ 0x4158, 0x9200 }, { 0x415a, 0x6b46 }, { 0x415c, 0x091f }, { 0x415e, 0xdbe7 },
	{ 0x4160, 0xffe7 }, { 0x4162, 0x94f8 }, { 0x4164, 0x7620 }, { 0x4166, 0x94f8 },
	{ 0x4168, 0x3c31 }, { 0x416a, 0x5a43 }, { 0x416c, 0xd3e7 }, { 0x416e, 0x6b46 },
	{ 0x4170, 0x091d }, { 0x4172, 0x00f0 }, { 0x4174, 0x5ff9 }, { 0x4176, 0x96f8 },
	{ 0x4178, 0x5e00 }, { 0x417a, 0x0028 }, { 0x417c, 0x02d0 }, { 0x417e, 0x2046 },
	{ 0x4180, 0x00f0 }, { 0x4182, 0x5df9 }, { 0x4184, 0xfebd }, { 0x4186, 0x70b5 },
	{ 0x4188, 0x4ff4 }, { 0x418a, 0x0141 }, { 0x418c, 0x0c20 }, { 0x418e, 0x00f0 },
	{ 0x4190, 0x5bf9 }, { 0x4192, 0x0446 }, { 0x4194, 0x314d }, { 0x4196, 0xc005 },
	{ 0x4198, 0x04d5 }, { 0x419a, 0x2888 }, { 0x419c, 0x401c }, { 0x419e, 0x2880 },
	{ 0x41a0, 0x00f0 }, { 0x41a2, 0x57f9 }, { 0x41a4, 0x2004 }, { 0x41a6, 0x06d5 },
	{ 0x41a8, 0x288c }, { 0x41aa, 0x401c }, { 0x41ac, 0x2884 }, { 0x41ae, 0xbde8 },
	{ 0x41b0, 0x7040 }, { 0x41b2, 0x00f0 }, { 0x41b4, 0x53b9 }, { 0x41b6, 0x70bd },
	{ 0x41b8, 0x2de9 }, { 0x41ba, 0xf041 }, { 0x41bc, 0xdff8 }, { 0x41be, 0x8080 },
	{ 0x41c0, 0x0220 }, { 0x41c2, 0x4446 }, { 0x41c4, 0x14f8 }, { 0x41c6, 0x711f },
	{ 0x41c8, 0x00f0 }, { 0x41ca, 0x3ef9 }, { 0x41cc, 0x86b2 }, { 0x41ce, 0x6078 },
	{ 0x41d0, 0x0127 }, { 0x41d2, 0x421e }, { 0x41d4, 0x07fa }, { 0x41d6, 0x02f1 },
	{ 0x41d8, 0x3142 }, { 0x41da, 0x15d0 }, { 0x41dc, 0x204c }, { 0x41de, 0x658f },
	{ 0x41e0, 0x41ea }, { 0x41e2, 0x0502 }, { 0x41e4, 0x6287 }, { 0x41e6, 0x4000 },
	{ 0x41e8, 0x0322 }, { 0x41ea, 0x801e }, { 0x41ec, 0x8240 }, { 0x41ee, 0xb4f8 },
	{ 0x41f0, 0x8e00 }, { 0x41f2, 0x20ea }, { 0x41f4, 0x0203 }, { 0x41f6, 0xa4f8 },
	{ 0x41f8, 0x8e30 }, { 0x41fa, 0x1043 }, { 0x41fc, 0xa4f8 }, { 0x41fe, 0x8e00 },
	{ 0x4200, 0x0220 }, { 0x4202, 0x00f0 }, { 0x4204, 0x21f9 }, { 0x4206, 0x6587 },
	{ 0x4208, 0x98f8 }, { 0x420a, 0x7500 }, { 0x420c, 0x3946 }, { 0x420e, 0x401e },
	{ 0x4210, 0x8740 }, { 0x4212, 0x3742 }, { 0x4214, 0x2cd0 }, { 0x4216, 0x114a },
	{ 0x4218, 0x908c }, { 0x421a, 0x401c }, { 0x421c, 0x9084 }, { 0x421e, 0x1148 },
	{ 0x4220, 0x0288 }, { 0x4222, 0x012a }, { 0x4224, 0x24d1 }, { 0x4226, 0x90f8 },
	{ 0x4228, 0x5421 }, { 0x422a, 0xfab1 }, { 0x422c, 0xbde8 }, { 0x422e, 0xf041 },
	{ 0x4230, 0x1ae0 }, { 0x4232, 0x0000 }, { 0x4234, 0x4000 }, { 0x4236, 0x8000 },
	{ 0x4238, 0x2000 }, { 0x423a, 0x3ca0 }, { 0x423c, 0x2000 }, { 0x423e, 0x44c0 },
	{ 0x4240, 0x2000 }, { 0x4242, 0x32c0 }, { 0x4244, 0x2000 }, { 0x4246, 0x3b50 },
	{ 0x4248, 0x2000 }, { 0x424a, 0xa000 }, { 0x424c, 0x2000 }, { 0x424e, 0x2f50 },
	{ 0x4250, 0x4000 }, { 0x4252, 0xac30 }, { 0x4254, 0x2000 }, { 0x4256, 0x09f0 },
	{ 0x4258, 0x4000 }, { 0x425a, 0xf000 }, { 0x425c, 0x2000 }, { 0x425e, 0x2790 },
	{ 0x4260, 0x4000 }, { 0x4262, 0x7000 }, { 0x4264, 0x2000 }, { 0x4266, 0x2570 },
	{ 0x4268, 0x00f0 }, { 0x426a, 0xfdb8 }, { 0x426c, 0x80f8 }, { 0x426e, 0x5511 },
	{ 0x4270, 0xa4e6 }, { 0x4272, 0x4079 }, { 0x4274, 0x38b1 }, { 0x4276, 0x1f23 },
	{ 0x4278, 0x8343 }, { 0x427a, 0x0122 }, { 0x427c, 0xaff2 }, { 0x427e, 0xc701 },
	{ 0x4280, 0x0220 }, { 0x4282, 0x00f0 }, { 0x4284, 0xf5b8 }, { 0x4286, 0x1f21 },
	{ 0x4288, 0x0220 }, { 0x428a, 0x00f0 }, { 0x428c, 0xf6b8 }, { 0x428e, 0x70b5 },
	{ 0x4290, 0x0446 }, { 0x4292, 0x4279 }, { 0x4294, 0x8079 }, { 0x4296, 0x18b1 },
	{ 0x4298, 0x0121 }, { 0x429a, 0x401e }, { 0x429c, 0x8140 }, { 0x429e, 0x00e0 },
	{ 0x42a0, 0x0021 }, { 0x42a2, 0x3348 }, { 0x42a4, 0x0a43 }, { 0x42a6, 0x6271 },
	{ 0x42a8, 0x0069 }, { 0x42aa, 0x0022 }, { 0x42ac, 0x86b2 }, { 0x42ae, 0x050c },
	{ 0x42b0, 0x3146 }, { 0x42b2, 0x2846 }, { 0x42b4, 0x00f0 }, { 0x42b6, 0x91f8 },
	{ 0x42b8, 0x2046 }, { 0x42ba, 0x00f0 }, { 0x42bc, 0xe3f8 }, { 0x42be, 0x0122 },
	{ 0x42c0, 0x3146 }, { 0x42c2, 0x2846 }, { 0x42c4, 0x00f0 }, { 0x42c6, 0x89f8 },
	{ 0x42c8, 0x0120 }, { 0x42ca, 0x70bd }, { 0x42cc, 0x10b5 }, { 0x42ce, 0x0022 },
	{ 0x42d0, 0xaff2 }, { 0x42d2, 0xb341 }, { 0x42d4, 0x2748 }, { 0x42d6, 0x00f0 },
	{ 0x42d8, 0xdaf8 }, { 0x42da, 0x274c }, { 0x42dc, 0x4bf6 }, { 0x42de, 0x5870 },
	{ 0x42e0, 0xe18c }, { 0x42e2, 0x00f0 }, { 0x42e4, 0xd9f8 }, { 0x42e6, 0xe08c },
	{ 0x42e8, 0x254a }, { 0x42ea, 0x2449 }, { 0x42ec, 0x42f8 }, { 0x42ee, 0x2010 },
	{ 0x42f0, 0x401c }, { 0x42f2, 0xe084 }, { 0x42f4, 0x0022 }, { 0x42f6, 0xaff2 },
	{ 0x42f8, 0x5541 }, { 0x42fa, 0x2248 }, { 0x42fc, 0x00f0 }, { 0x42fe, 0xc7f8 },
	{ 0x4300, 0x1b4c }, { 0x4302, 0x0022 }, { 0x4304, 0xaff2 }, { 0x4306, 0xef31 },
	{ 0x4308, 0x2060 }, { 0x430a, 0x1f48 }, { 0x430c, 0x00f0 }, { 0x430e, 0xbff8 },
	{ 0x4310, 0x0022 }, { 0x4312, 0xaff2 }, { 0x4314, 0xab31 }, { 0x4316, 0x6060 },
	{ 0x4318, 0x1c48 }, { 0x431a, 0x00f0 }, { 0x431c, 0xb8f8 }, { 0x431e, 0x0022 },
	{ 0x4320, 0xaff2 }, { 0x4322, 0x5d31 }, { 0x4324, 0xa060 }, { 0x4326, 0x1a48 },
	{ 0x4328, 0x00f0 }, { 0x432a, 0xb1f8 }, { 0x432c, 0x0022 }, { 0x432e, 0xaff2 },
	{ 0x4330, 0xbf21 }, { 0x4332, 0xe060 }, { 0x4334, 0x1748 }, { 0x4336, 0x00f0 },
	{ 0x4338, 0xaaf8 }, { 0x433a, 0x0022 }, { 0x433c, 0xaff2 }, { 0x433e, 0x8721 },
	{ 0x4340, 0x1548 }, { 0x4342, 0x00f0 }, { 0x4344, 0xa4f8 }, { 0x4346, 0x0022 },
	{ 0x4348, 0xaff2 }, { 0x434a, 0xc511 }, { 0x434c, 0x1348 }, { 0x434e, 0x00f0 },
	{ 0x4350, 0x9ef8 }, { 0x4352, 0x0022 }, { 0x4354, 0xaff2 }, { 0x4356, 0xe501 },
	{ 0x4358, 0x1148 }, { 0x435a, 0x00f0 }, { 0x435c, 0x98f8 }, { 0x435e, 0x0022 },
	{ 0x4360, 0xaff2 }, { 0x4362, 0xd501 }, { 0x4364, 0x0f48 }, { 0x4366, 0x00f0 },
	{ 0x4368, 0x92f8 }, { 0x436a, 0x2061 }, { 0x436c, 0x10bd }, { 0x436e, 0x0000 },
	{ 0x4370, 0x2000 }, { 0x4372, 0x44c0 }, { 0x4374, 0x0000 }, { 0x4376, 0xe7bd },
	{ 0x4378, 0x2000 }, { 0x437a, 0x3280 }, { 0x437c, 0xaff3 }, { 0x437e, 0x0080 },
	{ 0x4380, 0x2000 }, { 0x4382, 0x3cf0 }, { 0x4384, 0x0000 }, { 0x4386, 0xa4cd },
	{ 0x4388, 0x0000 }, { 0x438a, 0x58a5 }, { 0x438c, 0x0000 }, { 0x438e, 0x463f },
	{ 0x4390, 0x0000 }, { 0x4392, 0x5637 }, { 0x4394, 0x0000 }, { 0x4396, 0xa01f },
	{ 0x4398, 0x0000 }, { 0x439a, 0xc677 }, { 0x439c, 0x0000 }, { 0x439e, 0x049f },
	{ 0x43a0, 0x0000 }, { 0x43a2, 0x0641 }, { 0x43a4, 0x0000 }, { 0x43a6, 0xd7bb },
	{ 0x43a8, 0x4ef2 }, { 0x43aa, 0x8f3c }, { 0x43ac, 0xc0f2 }, { 0x43ae, 0x000c },
	{ 0x43b0, 0x6047 }, { 0x43b2, 0x4ef2 }, { 0x43b4, 0xed3c }, { 0x43b6, 0xc0f2 },
	{ 0x43b8, 0x000c }, { 0x43ba, 0x6047 }, { 0x43bc, 0x4ef2 }, { 0x43be, 0x814c },
	{ 0x43c0, 0xc0f2 }, { 0x43c2, 0x000c }, { 0x43c4, 0x6047 }, { 0x43c6, 0x4ef2 },
	{ 0x43c8, 0xa95c }, { 0x43ca, 0xc0f2 }, { 0x43cc, 0x000c }, { 0x43ce, 0x6047 },
	{ 0x43d0, 0x4ef2 }, { 0x43d2, 0xe33c }, { 0x43d4, 0xc0f2 }, { 0x43d6, 0x000c },
	{ 0x43d8, 0x6047 }, { 0x43da, 0x40f6 }, { 0x43dc, 0x032c }, { 0x43de, 0xc0f2 },
	{ 0x43e0, 0x000c }, { 0x43e2, 0x6047 }, { 0x43e4, 0x4af2 }, { 0x43e6, 0xcd4c },
	{ 0x43e8, 0xc0f2 }, { 0x43ea, 0x000c }, { 0x43ec, 0x6047 }, { 0x43ee, 0x45f6 },
	{ 0x43f0, 0xa50c }, { 0x43f2, 0xc0f2 }, { 0x43f4, 0x000c }, { 0x43f6, 0x6047 },
	{ 0x43f8, 0x44f2 }, { 0x43fa, 0x3f6c }, { 0x43fc, 0xc0f2 }, { 0x43fe, 0x000c },
	{ 0x4400, 0x6047 }, { 0x4402, 0x45f2 }, { 0x4404, 0x376c }, { 0x4406, 0xc0f2 },
	{ 0x4408, 0x000c }, { 0x440a, 0x6047 }, { 0x440c, 0x4cf2 }, { 0x440e, 0x610c },
	{ 0x4410, 0xc0f2 }, { 0x4412, 0x000c }, { 0x4414, 0x6047 }, { 0x4416, 0x4af2 },
	{ 0x4418, 0x070c }, { 0x441a, 0xc0f2 }, { 0x441c, 0x000c }, { 0x441e, 0x6047 },
	{ 0x4420, 0x4cf2 }, { 0x4422, 0x6b4c }, { 0x4424, 0xc0f2 }, { 0x4426, 0x000c },
	{ 0x4428, 0x6047 }, { 0x442a, 0x4cf2 }, { 0x442c, 0x275c }, { 0x442e, 0xc0f2 },
	{ 0x4430, 0x000c }, { 0x4432, 0x6047 }, { 0x4434, 0x4cf2 }, { 0x4436, 0x3f3c },
	{ 0x4438, 0xc0f2 }, { 0x443a, 0x000c }, { 0x443c, 0x6047 }, { 0x443e, 0x4cf2 },
	{ 0x4440, 0x094c }, { 0x4442, 0xc0f2 }, { 0x4444, 0x000c }, { 0x4446, 0x6047 },
	{ 0x4448, 0x40f2 }, { 0x444a, 0xe91c }, { 0x444c, 0xc0f2 }, { 0x444e, 0x000c },
	{ 0x4450, 0x6047 }, { 0x4452, 0x4bf2 }, { 0x4454, 0x6b5c }, { 0x4456, 0xc0f2 },
	{ 0x4458, 0x000c }, { 0x445a, 0x6047 }, { 0x445c, 0x46f6 }, { 0x445e, 0x6d0c },
	{ 0x4460, 0xc0f2 }, { 0x4462, 0x000c }, { 0x4464, 0x6047 }, { 0x4466, 0x4ff2 },
	{ 0x4468, 0xfd0c }, { 0x446a, 0xc0f2 }, { 0x446c, 0x000c }, { 0x446e, 0x6047 },
	{ 0x4470, 0x40f2 }, { 0x4472, 0x532c }, { 0x4474, 0xc0f2 }, { 0x4476, 0x000c },
	{ 0x4478, 0x6047 }, { 0x447a, 0x40f2 }, { 0x447c, 0xd12c }, { 0x447e, 0xc0f2 },
	{ 0x4480, 0x000c }, { 0x4482, 0x6047 }, { 0x4484, 0x4df2 }, { 0x4486, 0xbb7c },
	{ 0x4488, 0xc0f2 }, { 0x448a, 0x000c }, { 0x448c, 0x6047 }, { 0x448e, 0x43f2 },
	{ 0x4490, 0xbb1c }, { 0x4492, 0xc0f2 }, { 0x4494, 0x010c }, { 0x4496, 0x6047 },
	{ 0x4498, 0x43f2 }, { 0x449a, 0x5b1c }, { 0x449c, 0xc0f2 }, { 0x449e, 0x010c },
	{ 0x44a0, 0x6047 }, { 0x44a2, 0x0000 }, { 0x44a4, 0x0000 }, { 0x44a6, 0x0000 },
	{ 0x44a8, 0x0000 }, { 0x44aa, 0x0000 }, { 0x44ac, 0x0000 }, { 0x44ae, 0x0000 },
	{ 0xfcfc, 0x4000 }, { 0x6000, 0x0085 }, { 0x0200, 0x0000 }, { 0x0202, 0x0620 },
	{ 0x0204, 0x0020 }, { 0x0216, 0x0000 }, { 0x021c, 0x0000 }, { 0x021e, 0x0040 },
	{ 0x0900, 0x0111 }, { 0x0b00, 0x0080 }, { 0x0b04, 0x0101 }, { 0x0b08, 0x0000 },
	{ 0x0b0e, 0x0000 }, { 0x112c, 0x4220 }, { 0x112e, 0x0000 }, { 0x3000, 0x0001 },
	{ 0x3050, 0x0000 }, { 0x3052, 0x0400 }, { 0x3054, 0x0000 }, { 0x305e, 0x0000 },
	{ 0x306a, 0x0340 }, { 0x3076, 0x0000 }, { 0x319e, 0x0100 }, { 0x31e0, 0x0000 },
	{ 0x31e2, 0x0000 }, { 0x31e4, 0x0000 }, { 0x31f8, 0x0008 }, { 0x31fa, 0x1158 },
	{ 0x3264, 0x0009 }, { 0x3284, 0x0044 }, { 0x3290, 0x0000 }, { 0x3298, 0x0020 },
	{ 0x33e0, 0x00b9 }, { 0x33e4, 0x006f }, { 0x33e8, 0x0076 }, { 0x33ec, 0x011a },
	{ 0x33f0, 0x0004 }, { 0x33f4, 0x0000 }, { 0x33f8, 0x0000 }, { 0x33fc, 0x0000 },
	{ 0x3400, 0x00b9 }, { 0x3404, 0x006f }, { 0x3408, 0x0076 }, { 0x340c, 0x011a },
	{ 0x3410, 0x0004 }, { 0x3414, 0x0000 }, { 0x3418, 0x0000 }, { 0x341c, 0x0000 },
	{ 0x3834, 0x0803 }, { 0x3842, 0x240f }, { 0x3844, 0x00ff }, { 0x3850, 0x005a },
	{ 0x655e, 0x03e8 }, { 0xb134, 0x0180 }, { 0xb13c, 0x0400 }, { 0xf150, 0x000a },
	{ 0xf160, 0x000b }, { 0xf458, 0x0009 }, { 0xf45a, 0x000e }, { 0xf45c, 0x000e },
	{ 0xf45e, 0x0018 }, { 0xf460, 0x0010 }, { 0xf462, 0x0018 }, { 0xf46c, 0x002d },
	{ 0xf47a, 0x00fc }, { 0xf47c, 0x0000 }, { 0xf404, 0x0ff3 }, { 0xf426, 0x00a0 },
	{ 0xf428, 0x44c2 }, { 0xf486, 0x0480 }, { 0xf4ae, 0x003c }, { 0xf4b0, 0x1124 },
	{ 0xf4b2, 0x003d }, { 0xf4b4, 0x1125 }, { 0xf4b6, 0x0044 }, { 0xf4b8, 0x112c },
	{ 0xf4ba, 0x0045 }, { 0xf4bc, 0x112d }, { 0xf4be, 0x004c }, { 0xf4c0, 0x1134 },
	{ 0xf4c2, 0x004d }, { 0xf4c4, 0x1135 },
};

static const struct s5k2xx_reg s5k2x7_mode_2832x2124_regs[] = {
	{ 0x6000, 0x0005 }, { 0xfcfc, 0x2000 }, { 0x00e0, 0x0100 }, { 0x03e0, 0x0001 },
	{ 0x03e2, 0x0100 }, { 0x03e4, 0x0000 }, { 0x03f4, 0x0100 }, { 0x03f6, 0x0120 },
	{ 0x2750, 0x0100 }, { 0x2770, 0x0100 }, { 0xfcfc, 0x4000 }, { 0x6000, 0x0085 },
	{ 0x0306, 0x00f0 }, { 0x030c, 0x0004 }, { 0x030e, 0x0183 }, { 0x0340, 0x1088 },
	{ 0x0342, 0x1d88 }, { 0x0344, 0x0000 }, { 0x0346, 0x0004 }, { 0x0348, 0x161f },
	{ 0x034a, 0x109b }, { 0x034c, 0x0b10 }, { 0x034e, 0x084c }, { 0x0380, 0x0002 },
	{ 0x0382, 0x0002 }, { 0x0384, 0x0002 }, { 0x0386, 0x0002 }, { 0x3002, 0x0100 },
	{ 0x306e, 0x0000 }, { 0x3070, 0x0000 }, { 0x3072, 0x0000 }, { 0x3074, 0x0000 },
	{ 0x31a0, 0x0050 }, { 0x31c0, 0x0004 }, { 0x324a, 0x0300 }, { 0x3258, 0x0036 },
	{ 0x3260, 0x002a }, { 0x3268, 0x0001 }, { 0x3270, 0x0024 }, { 0x3288, 0x0030 },
	{ 0x32a0, 0x0024 }, { 0x32c4, 0x0029 }, { 0x337c, 0x0066 }, { 0x3458, 0x002e },
	{ 0x382e, 0x060f }, { 0x3830, 0x0805 }, { 0x3832, 0x0605 }, { 0x3840, 0x0064 },
	{ 0xf424, 0x0000 }, { 0x30b6, 0x0004 }, { 0x30b8, 0x0500 }, { 0x30be, 0x0000 },
	{ 0x30c2, 0x0100 }, { 0x30c4, 0x0100 }, { 0x30c0, 0x0100 }, { 0x300c, 0x0001 },
	{ 0x3844, 0x00bf },
};

	//{ 0x0306, 0x00f0 }, { 0x030c, 0x0002 }, { 0x030e, 0x00af }, { 0x0340, 0x1198 },
	//{ 0x0342, 0x1bc0 }, { 0x0344, 0x0000 }, { 0x0346, 0x0004 }, { 0x0348, 0x161f },
static const struct s5k2xx_reg s5k2x7_mode_5664x4248_regs[] = {
	{ 0x6000, 0x0005 }, { 0xfcfc, 0x2000 }, { 0x00e0, 0x0000 }, { 0x03e0, 0x0000 },
	{ 0x03e2, 0x0101 }, { 0x03e4, 0x0001 }, { 0x03f4, 0x0000 }, { 0x03f6, 0x0020 },
	{ 0x2750, 0x0100 }, { 0x2770, 0x0100 }, { 0xfcfc, 0x4000 }, { 0x6000, 0x0085 },
	{ 0x0306, 0x00f0 }, { 0x030c, 0x0002 }, { 0x030e, 0x00af }, { 0x0340, 0x1100 },
	{ 0x0342, 0x1800 }, { 0x0344, 0x0000 }, { 0x0346, 0x0004 }, { 0x0348, 0x161f },
	{ 0x034a, 0x109b }, { 0x034c, 0x1620 }, { 0x034e, 0x1098 }, { 0x0380, 0x0001 },
	{ 0x0382, 0x0001 }, { 0x0384, 0x0001 }, { 0x0386, 0x0001 }, { 0x3002, 0x0000 },
	{ 0x306e, 0x0100 }, { 0x3070, 0x0000 }, { 0x3072, 0x0001 }, { 0x3074, 0x0001 },
	{ 0x31a0, 0x0050 }, { 0x31c0, 0x0008 }, { 0x324a, 0x0100 }, { 0x3258, 0x0012 },
	{ 0x3260, 0x0036 }, { 0x3268, 0x0036 }, { 0x3270, 0x0030 }, { 0x3288, 0x0024 },
	{ 0x32a0, 0x0018 }, { 0x32c4, 0x0035 }, { 0x337c, 0x005a }, { 0x3458, 0x0046 },
	{ 0x382e, 0x090f }, { 0x3830, 0x0f05 }, { 0x3832, 0x0005 }, { 0x3840, 0x0064 },
	{ 0xf424, 0x0040 }, { 0x30b6, 0x0004 }, { 0x30b8, 0x0500 }, { 0x30be, 0x0000 },
	{ 0x30c2, 0x0100 }, { 0x30c4, 0x0100 }, { 0x30c0, 0x0100 }, { 0x300c, 0x0000 },
	{ 0x3844, 0x00ff },
};
static const struct s5k2xx_reg s5k2x7_mode_640x480_regs[] = {
	{ 0x6000, 0x0005 }, { 0xfcfc, 0x2000 }, { 0x00e0, 0x0100 }, { 0x03e0, 0x0001 },
	{ 0x03e2, 0x0100 }, { 0x03e4, 0x0000 }, { 0x03f4, 0x0100 }, { 0x03f6, 0x0120 },
	{ 0x2750, 0x0100 }, { 0x2770, 0x0100 }, { 0xfcfc, 0x4000 }, { 0x6000, 0x0085 },
	{ 0x0306, 0x00f0 }, { 0x030c, 0x0004 }, { 0x030e, 0x0183 }, { 0x0340, 0x0839 },
	{ 0x0342, 0x0ed8 }, { 0x0344, 0x0890 }, { 0x0346, 0x0670 }, { 0x0348, 0x0d90 },
	{ 0x034a, 0x0a30 }, { 0x034c, 0x0280 }, { 0x034e, 0x01e0 }, { 0x0380, 0x0002 },
	{ 0x0382, 0x0002 }, { 0x0384, 0x0002 }, { 0x0386, 0x0002 }, { 0x3002, 0x0100 },
	{ 0x306e, 0x0000 }, { 0x3070, 0x0000 }, { 0x3072, 0x0000 }, { 0x3074, 0x0000 },
	{ 0x31a0, 0xffff }, { 0x31c0, 0x0004 }, { 0x324a, 0x0300 }, { 0x3258, 0x0036 },
	{ 0x3260, 0x002a }, { 0x3268, 0x0001 }, { 0x3270, 0x0024 }, { 0x3288, 0x0030 },
	{ 0x32a0, 0x0024 }, { 0x32c4, 0x0029 }, { 0x337c, 0x0066 }, { 0x3458, 0x002e },
	{ 0x382e, 0x060f }, { 0x3830, 0x0805 }, { 0x3832, 0x0605 }, { 0x3840, 0x0064 },
	{ 0xf424, 0x0000 }, { 0x30b6, 0x0004 }, { 0x30b8, 0x0500 }, { 0x30be, 0x0000 },
	{ 0x30c2, 0x0100 }, { 0x30c4, 0x0100 }, { 0x30c0, 0x0100 }, { 0x300c, 0x0001 },
	{ 0x3844, 0x00bf },
};

static const struct s5k2xx_mode s5k2x7_modes[] = {
	{
		.width = 2832,
		.height = 2124,
		.fps = 30,
		.fll_def = 4232,
		.fll_min = 4232,
		.llp = 7560,
		.pixel_rate = 550000000,
		.reg_list = {
			.num_regs = ARRAY_SIZE(s5k2x7_mode_2832x2124_regs),
			.regs = s5k2x7_mode_2832x2124_regs,
		},
	}, {
		.width = 5664,
		.height = 4248,
		.fps = 30,
		.fll_def = 4504,
		.fll_min = 4504,
		.llp = 7104,
		.pixel_rate = 800000000,
		.reg_list = {
			.num_regs = ARRAY_SIZE(s5k2x7_mode_5664x4248_regs),
			.regs = s5k2x7_mode_5664x4248_regs,
		},
	}, {
		.width = 640,
		.height = 480,
		.fps = 120,
		.fll_def = 2105,
		.fll_min = 2105,
		.llp = 3800,
		.pixel_rate = 464400000,
		.reg_list = {
			.num_regs = ARRAY_SIZE(s5k2x7_mode_640x480_regs),
			.regs = s5k2x7_mode_640x480_regs,
		},
	},
};

static struct s5k2xx_data s5k2x7sp_data = {
	.name = "s5k2x7sp",
	.chip_id = 0x2187,
	.reg_init = {
		.regs = s5k2x7_init,
		.num_regs = ARRAY_SIZE(s5k2x7_init),
	},
	.modes = s5k2x7_modes,
	.num_modes = ARRAY_SIZE(s5k2x7_modes),
};

struct s5k2xx {
	struct v4l2_subdev sd;
	struct media_pad pad;
	struct v4l2_ctrl_handler ctrl_handler;

	/* V4L2 Controls */
	struct v4l2_ctrl *pixel_rate;
	struct v4l2_ctrl *vblank;
	struct v4l2_ctrl *hblank;
	struct v4l2_ctrl *exposure;

	struct regulator_bulk_data supplies[S5K2XX_NUM_SUPPLIES];
	struct clk	 *mclk;
	struct gpio_desc *reset_gpio;
	int enabled;

	/* Current mode */
	const struct s5k2xx_mode *cur_mode;
	const struct s5k2xx_data *data;

	/* To serialize asynchronus callbacks */
	struct mutex lock;

	/* Streaming on/off */
	bool streaming;
};

static int s5k2xx_read_reg(struct s5k2xx *s5k2xx, u16 reg, u16 len, u32 *val)
{
	struct i2c_client *client = v4l2_get_subdevdata(&s5k2xx->sd);
	struct i2c_msg msgs[2];
	u8 addr_buf[2];
	u8 data_buf[4] = {0};
	int ret;

	if (len > 4)
		return -EINVAL;

	put_unaligned_be16(reg, addr_buf);
	msgs[0].addr = client->addr;
	msgs[0].flags = 0;
	msgs[0].len = sizeof(addr_buf);
	msgs[0].buf = addr_buf;
	msgs[1].addr = client->addr;
	msgs[1].flags = I2C_M_RD;
	msgs[1].len = len;
	msgs[1].buf = &data_buf[4 - len];

	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
	if (ret != ARRAY_SIZE(msgs))
		return -EIO;

	*val = get_unaligned_be32(data_buf);

	return 0;
}

static int s5k2xx_write_reg(struct s5k2xx *s5k2xx, u16 reg, u16 len, u32 val)
{
	struct i2c_client *client = v4l2_get_subdevdata(&s5k2xx->sd);
	u8 buf[6];

	if (len > 4)
		return -EINVAL;

	put_unaligned_be16(reg, buf);
	put_unaligned_be32(val << 8 * (4 - len), buf + 2);
	if (i2c_master_send(client, buf, len + 2) != len + 2)
		return -EIO;

	return 0;
}

static int s5k2xx_write_reg_list(struct s5k2xx *s5k2xx,
				const struct s5k2xx_reg_list *r_list)
{
	struct i2c_client *client = v4l2_get_subdevdata(&s5k2xx->sd);
	unsigned int i;
	int ret;

	for (i = 0; i < r_list->num_regs; i++) {
		ret = s5k2xx_write_reg(s5k2xx, r_list->regs[i].address,
				      S5K2XX_REG_VALUE_16BIT,
				      r_list->regs[i].val);
		if (ret) {
			dev_err_ratelimited(&client->dev,
					    "failed to write reg 0x%4.4x. error = %d",
					    r_list->regs[i].address, ret);
			return ret;
		}
	}

	return 0;
}

static int s5k2xx_set_ctrl(struct v4l2_ctrl *ctrl)
{
	struct s5k2xx *s5k2xx = container_of(ctrl->handler,
					     struct s5k2xx, ctrl_handler);
	struct i2c_client *client = v4l2_get_subdevdata(&s5k2xx->sd);
	s64 exposure_max;
	int ret = 0;

	return 0;

	/* Propagate change of current control to all related controls */
	if (ctrl->id == V4L2_CID_VBLANK) {
		/* Update max exposure while meeting expected vblanking */
		exposure_max = s5k2xx->cur_mode->height + ctrl->val -
			       S5K2XX_EXPOSURE_MAX_MARGIN;
		__v4l2_ctrl_modify_range(s5k2xx->exposure,
					 s5k2xx->exposure->minimum,
					 exposure_max, s5k2xx->exposure->step,
					 exposure_max);
	}

	/* V4L2 controls values will be applied only when power is already up */
	if (!pm_runtime_get_if_in_use(&client->dev))
		return 0;

	switch (ctrl->id) {
	case V4L2_CID_ANALOGUE_GAIN:
	case V4L2_CID_DIGITAL_GAIN:
	case V4L2_CID_EXPOSURE:
	case V4L2_CID_VBLANK:
		ret = 0;
		// TODO
		break;
	default:
		ret = -EINVAL;
		break;
	}

	pm_runtime_put(&client->dev);

	return ret;
}

static const struct v4l2_ctrl_ops s5k2xx_ctrl_ops = {
	.s_ctrl = s5k2xx_set_ctrl,
};

static u32 calc_pixel_rate(const struct s5k2xx_mode *mode)
{
	return mode->pixel_rate;
}

static int s5k2xx_init_controls(struct s5k2xx *s5k2xx)
{
	struct v4l2_ctrl_handler *ctrl_hdlr;
	s64 exposure_max, h_blank;
	int ret;

	ctrl_hdlr = &s5k2xx->ctrl_handler;
	ret = v4l2_ctrl_handler_init(ctrl_hdlr, 8);
	if (ret)
		return ret;

	ctrl_hdlr->lock = &s5k2xx->lock;
	s5k2xx->pixel_rate = v4l2_ctrl_new_std
			    (ctrl_hdlr, &s5k2xx_ctrl_ops,
			     V4L2_CID_PIXEL_RATE, 0,
			     calc_pixel_rate(s5k2xx->cur_mode),
			     1,
			     calc_pixel_rate(s5k2xx->cur_mode));
	s5k2xx->vblank = v4l2_ctrl_new_std(ctrl_hdlr, &s5k2xx_ctrl_ops,
					  V4L2_CID_VBLANK,
					  s5k2xx->cur_mode->fll_min -
					  s5k2xx->cur_mode->height,
					  S5K2XX_FLL_MAX -
					  s5k2xx->cur_mode->height, 1,
					  s5k2xx->cur_mode->fll_def -
					  s5k2xx->cur_mode->height);

	h_blank = s5k2xx->cur_mode->llp - s5k2xx->cur_mode->width;

	s5k2xx->hblank = v4l2_ctrl_new_std(ctrl_hdlr, &s5k2xx_ctrl_ops,
					  V4L2_CID_HBLANK, h_blank, h_blank, 1,
					  h_blank);
	if (s5k2xx->hblank)
		s5k2xx->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;

	v4l2_ctrl_new_std(ctrl_hdlr, &s5k2xx_ctrl_ops, V4L2_CID_ANALOGUE_GAIN,
			  S5K2XX_ANAL_GAIN_MIN, S5K2XX_ANAL_GAIN_MAX,
			  S5K2XX_ANAL_GAIN_STEP, S5K2XX_ANAL_GAIN_MIN);
	v4l2_ctrl_new_std(ctrl_hdlr, &s5k2xx_ctrl_ops, V4L2_CID_DIGITAL_GAIN,
			  S5K2XX_DGTL_GAIN_MIN, S5K2XX_DGTL_GAIN_MAX,
			  S5K2XX_DGTL_GAIN_STEP, S5K2XX_DGTL_GAIN_DEFAULT);
	exposure_max = s5k2xx->cur_mode->fll_def - S5K2XX_EXPOSURE_MAX_MARGIN;
	s5k2xx->exposure = v4l2_ctrl_new_std(ctrl_hdlr, &s5k2xx_ctrl_ops,
					    V4L2_CID_EXPOSURE,
					    S5K2XX_EXPOSURE_MIN, exposure_max,
					    S5K2XX_EXPOSURE_STEP,
					    exposure_max);
	if (ctrl_hdlr->error)
		return ctrl_hdlr->error;

	s5k2xx->sd.ctrl_handler = ctrl_hdlr;

	return 0;
}

static void s5k2xx_assign_pad_format(const struct s5k2xx_mode *mode,
				    struct v4l2_mbus_framefmt *fmt)
{
	fmt->width = mode->width;
	fmt->height = mode->height;
	fmt->code = MEDIA_BUS_FMT_SGRBG10_1X10;
	fmt->field = V4L2_FIELD_NONE;
}

static int s5k2xx_start_streaming(struct s5k2xx *s5k2xx)
{
	struct i2c_client *client = v4l2_get_subdevdata(&s5k2xx->sd);
	int ret;

	ret = s5k2xx_write_reg_list(s5k2xx, &s5k2xx->data->reg_init);
	if (ret) {
		dev_err(&client->dev, "failed to set plls");
		return ret;
	}

	ret = s5k2xx_write_reg_list(s5k2xx, &s5k2xx->cur_mode->reg_list);
	if (ret) {
		dev_err(&client->dev, "failed to set mode");
		return ret;
	}

	ret = __v4l2_ctrl_handler_setup(s5k2xx->sd.ctrl_handler);
	if (ret)
		return ret;

	ret = s5k2xx_write_reg(s5k2xx, 0x6028, S5K2XX_REG_VALUE_16BIT, 0x4000);
	if (ret) {
		dev_err(&client->dev, "failed to set page");
		return ret;
	}

	ret = s5k2xx_write_reg(s5k2xx, S5K2XX_REG_MODE_SELECT,
			      S5K2XX_REG_VALUE_16BIT, S5K2XX_MODE_STREAMING);

	if (ret) {
		dev_err(&client->dev, "failed to set stream");
		return ret;
	}

	return 0;
}

static void s5k2xx_stop_streaming(struct s5k2xx *s5k2xx)
{
	struct i2c_client *client = v4l2_get_subdevdata(&s5k2xx->sd);

	if (s5k2xx_write_reg(s5k2xx, 0x6028, S5K2XX_REG_VALUE_16BIT, 0x4000))
		dev_err(&client->dev, "failed to set page");

	if (s5k2xx_write_reg(s5k2xx, S5K2XX_REG_MODE_SELECT,
			    S5K2XX_REG_VALUE_16BIT, S5K2XX_MODE_STANDBY))
		dev_err(&client->dev, "failed to set stream");
}

static int s5k2xx_set_stream(struct v4l2_subdev *sd, int enable)
{
	struct s5k2xx *s5k2xx = to_s5k2(sd);
	struct i2c_client *client = v4l2_get_subdevdata(sd);
	int ret = 0;

	if (s5k2xx->streaming == enable)
		return 0;

	mutex_lock(&s5k2xx->lock);
	if (enable) {
		ret = pm_runtime_get_sync(&client->dev);
		if (ret < 0) {
			pm_runtime_put_noidle(&client->dev);
			mutex_unlock(&s5k2xx->lock);
			return ret;
		}

		ret = s5k2xx_start_streaming(s5k2xx);
		if (ret) {
			enable = 0;
			s5k2xx_stop_streaming(s5k2xx);
			pm_runtime_put(&client->dev);
		}
	} else {
		s5k2xx_stop_streaming(s5k2xx);
		pm_runtime_put(&client->dev);
	}

	s5k2xx->streaming = enable;
	mutex_unlock(&s5k2xx->lock);

	return ret;
}

static int __maybe_unused s5k2xx_suspend(struct device *dev)
{
	struct i2c_client *client = to_i2c_client(dev);
	struct v4l2_subdev *sd = i2c_get_clientdata(client);
	struct s5k2xx *s5k2xx = to_s5k2(sd);

	mutex_lock(&s5k2xx->lock);
	if (s5k2xx->streaming)
		s5k2xx_stop_streaming(s5k2xx);

	mutex_unlock(&s5k2xx->lock);

	return 0;
}

static int __maybe_unused s5k2xx_resume(struct device *dev)
{
	struct i2c_client *client = to_i2c_client(dev);
	struct v4l2_subdev *sd = i2c_get_clientdata(client);
	struct s5k2xx *s5k2xx = to_s5k2(sd);
	int ret;

	mutex_lock(&s5k2xx->lock);
	if (s5k2xx->streaming) {
		ret = s5k2xx_start_streaming(s5k2xx);
		if (ret)
			goto error;
	}

	mutex_unlock(&s5k2xx->lock);

	return 0;

error:
	s5k2xx_stop_streaming(s5k2xx);
	s5k2xx->streaming = 0;
	mutex_unlock(&s5k2xx->lock);
	return ret;
}

static int s5k2xx_power_on(struct device *dev)
{
	struct i2c_client *client = to_i2c_client(dev);
	struct v4l2_subdev *sd = i2c_get_clientdata(client);
	struct s5k2xx *s5k2xx = to_s5k2(sd);
	int ret;

	if ((s5k2xx->enabled)++)
		return 0;

	ret = regulator_bulk_enable(S5K2XX_NUM_SUPPLIES,
				    s5k2xx->supplies);
	if (ret) {
		dev_err(&client->dev, "%s: failed to enable regulators\n",
			__func__);
		return ret;
	}

	if (s5k2xx->mclk) {
		ret = clk_set_rate(s5k2xx->mclk, S5K2XX_MCLK);
		if (ret) {
			dev_err(dev, "can't set clock frequency");
			return ret;
		}
	}

	ret = clk_prepare_enable(s5k2xx->mclk);
	if (ret) {
		dev_err(&client->dev, "%s: failed to enable clock\n",
			__func__);
		goto reg_off;
	}

	gpiod_set_value_cansleep(s5k2xx->reset_gpio, 0);
	usleep_range(10000, 11000);

	return 0;

reg_off:
	regulator_bulk_disable(S5K2XX_NUM_SUPPLIES, s5k2xx->supplies);

	return ret;
}

static int s5k2xx_power_off(struct device *dev)
{
	struct i2c_client *client = to_i2c_client(dev);
	struct v4l2_subdev *sd = i2c_get_clientdata(client);
	struct s5k2xx *s5k2xx = to_s5k2(sd);

	if (--(s5k2xx->enabled) > 0)
		return 0;

	gpiod_set_value_cansleep(s5k2xx->reset_gpio, 1);

	regulator_bulk_disable(S5K2XX_NUM_SUPPLIES, s5k2xx->supplies);
	clk_disable_unprepare(s5k2xx->mclk);

	return 0;
}

static int s5k2xx_set_format(struct v4l2_subdev *sd,
			    struct v4l2_subdev_pad_config *cfg,
			    struct v4l2_subdev_format *fmt)
{
	struct s5k2xx *s5k2xx = to_s5k2(sd);
	const struct s5k2xx_mode *mode;
	s32 vblank_def, h_blank;

	mode = v4l2_find_nearest_size(s5k2xx->data->modes,
				      s5k2xx->data->num_modes, width,
				      height, fmt->format.width,
				      fmt->format.height);

	mutex_lock(&s5k2xx->lock);
	s5k2xx_assign_pad_format(mode, &fmt->format);
	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
		*v4l2_subdev_get_try_format(sd, cfg, fmt->pad) = fmt->format;
	} else {
		s5k2xx->cur_mode = mode;
		__v4l2_ctrl_s_ctrl_int64(s5k2xx->pixel_rate,
					 calc_pixel_rate(mode));

		/* Update limits and set FPS to default */
		vblank_def = mode->fll_def - mode->height;
		__v4l2_ctrl_modify_range(s5k2xx->vblank,
					 mode->fll_min - mode->height,
					 S5K2XX_FLL_MAX - mode->height, 1,
					 vblank_def);
		__v4l2_ctrl_s_ctrl(s5k2xx->vblank, vblank_def);

		h_blank = s5k2xx->cur_mode->llp - s5k2xx->cur_mode->width;

		__v4l2_ctrl_modify_range(s5k2xx->hblank, h_blank, h_blank, 1,
					 h_blank);
	}

	mutex_unlock(&s5k2xx->lock);

	return 0;
}

static int s5k2xx_get_format(struct v4l2_subdev *sd,
			    struct v4l2_subdev_pad_config *cfg,
			    struct v4l2_subdev_format *fmt)
{
	struct s5k2xx *s5k2xx = to_s5k2(sd);

	mutex_lock(&s5k2xx->lock);
	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
		fmt->format = *v4l2_subdev_get_try_format(&s5k2xx->sd, cfg,
							  fmt->pad);
	else
		s5k2xx_assign_pad_format(s5k2xx->cur_mode, &fmt->format);

	mutex_unlock(&s5k2xx->lock);

	return 0;
}

static int s5k2xx_enum_mbus_code(struct v4l2_subdev *sd,
				struct v4l2_subdev_pad_config *cfg,
				struct v4l2_subdev_mbus_code_enum *code)
{
	if (code->index > 0)
		return -EINVAL;

	code->code = MEDIA_BUS_FMT_SGRBG10_1X10;

	return 0;
}

static int s5k2xx_enum_frame_size(struct v4l2_subdev *sd,
				 struct v4l2_subdev_pad_config *cfg,
				 struct v4l2_subdev_frame_size_enum *fse)
{
	struct s5k2xx *s5k2xx = to_s5k2(sd);

	if (fse->index >= s5k2xx->data->num_modes)
		return -EINVAL;

	if (fse->code != MEDIA_BUS_FMT_SGRBG10_1X10)
		return -EINVAL;

	fse->min_width = s5k2xx->data->modes[fse->index].width;
	fse->max_width = fse->min_width;
	fse->min_height = s5k2xx->data->modes[fse->index].height;
	fse->max_height = fse->min_height;

	return 0;
}

static int s5k2xx_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
{
	struct s5k2xx *s5k2xx = to_s5k2(sd);

	mutex_lock(&s5k2xx->lock);
	s5k2xx_assign_pad_format(&s5k2xx->data->modes[0],
				v4l2_subdev_get_try_format(sd, fh->pad, 0));
	mutex_unlock(&s5k2xx->lock);

	return 0;
}

static const struct v4l2_subdev_video_ops s5k2xx_video_ops = {
	.s_stream = s5k2xx_set_stream,
};

static const struct v4l2_subdev_pad_ops s5k2xx_pad_ops = {
	.set_fmt = s5k2xx_set_format,
	.get_fmt = s5k2xx_get_format,
	.enum_mbus_code = s5k2xx_enum_mbus_code,
	.enum_frame_size = s5k2xx_enum_frame_size,
};

static const struct v4l2_subdev_ops s5k2xx_subdev_ops = {
	.video = &s5k2xx_video_ops,
	.pad = &s5k2xx_pad_ops,
};

static const struct media_entity_operations s5k2xx_subdev_entity_ops = {
	.link_validate = v4l2_subdev_link_validate,
};

static const struct v4l2_subdev_internal_ops s5k2xx_internal_ops = {
	.open = s5k2xx_open,
};

static int s5k2xx_identify_module(struct s5k2xx *s5k2xx)
{
	struct i2c_client *client = v4l2_get_subdevdata(&s5k2xx->sd);
	int ret;
	u32 val;

	ret = s5k2xx_read_reg(s5k2xx, S5K2XX_REG_CHIP_ID,
			     S5K2XX_REG_VALUE_16BIT, &val);
	if (ret)
		return ret;

	if (val != s5k2xx->data->chip_id) {
		dev_err(&client->dev, "chip id mismatch: %x!=%x",
			S5K2XX_CHIP_ID, val);
		return -ENXIO;
	}

	return 0;
}

static int s5k2xx_check_hwcfg(struct s5k2xx *s5k2xx, struct device *dev)
{
	struct fwnode_handle *ep;
	struct fwnode_handle *fwnode = dev_fwnode(dev);
	struct v4l2_fwnode_endpoint bus_cfg = {
		.bus_type = V4L2_MBUS_CSI2_DPHY
	};
	u32 mclk;
	int ret = 0;

	if (!fwnode)
		return -ENXIO;

	ret = fwnode_property_read_u32(fwnode, "clock-frequency", &mclk);
	if (ret) {
		dev_err(dev, "can't get clock frequency");
		return ret;
	}

	if (mclk != S5K2XX_MCLK) {
		dev_err(dev, "external clock %d is not supported", mclk);
		return -EINVAL;
	}

	ep = fwnode_graph_get_next_endpoint(fwnode, NULL);
	if (!ep)
		return -ENXIO;

	ret = v4l2_fwnode_endpoint_alloc_parse(ep, &bus_cfg);
	fwnode_handle_put(ep);
	if (ret)
		return ret;

	if (bus_cfg.bus.mipi_csi2.num_data_lanes != S5K2XX_DATA_LANES) {
		dev_err(dev, "number of CSI2 data lanes %d is not supported",
			bus_cfg.bus.mipi_csi2.num_data_lanes);
		ret = -EINVAL;
	}

	v4l2_fwnode_endpoint_free(&bus_cfg);

	return ret;
}

static int s5k2xx_remove(struct i2c_client *client)
{
	struct v4l2_subdev *sd = i2c_get_clientdata(client);
	struct s5k2xx *s5k2xx = to_s5k2(sd);

	v4l2_async_unregister_subdev(sd);
	media_entity_cleanup(&sd->entity);
	v4l2_ctrl_handler_free(sd->ctrl_handler);
	pm_runtime_disable(&client->dev);
	mutex_destroy(&s5k2xx->lock);

	return 0;
}

static int s5k2xx_of_init(struct s5k2xx *s5k2xx, struct device *dev)
{
	int i, ret;

	if (!dev->of_node)
		return 0;

	s5k2xx->data = (struct s5k2xx_data*) of_device_get_match_data(dev);

	for (i = 0; i < S5K2XX_NUM_SUPPLIES; i++)
		s5k2xx->supplies[i].supply = s5k2xx_supply_names[i];

	ret = devm_regulator_bulk_get(dev, S5K2XX_NUM_SUPPLIES, s5k2xx->supplies);
	if (ret < 0)
		return ret;

	s5k2xx->mclk = devm_clk_get_optional(dev, NULL);
	if (IS_ERR(s5k2xx->mclk))
		return PTR_ERR(s5k2xx->mclk);

	/* Request optional enable pin */
	s5k2xx->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);
	if (IS_ERR(s5k2xx->reset_gpio))
		return PTR_ERR(s5k2xx->reset_gpio);

	return 0;
}

static int s5k2xx_probe(struct i2c_client *client)
{
	struct s5k2xx *s5k2xx;
	int ret;

	s5k2xx = devm_kzalloc(&client->dev, sizeof(*s5k2xx), GFP_KERNEL);
	if (!s5k2xx)
		return -ENOMEM;

	ret = s5k2xx_of_init(s5k2xx, &client->dev);
	if (ret)
		return ret;

	ret = s5k2xx_check_hwcfg(s5k2xx, &client->dev);
	if (ret) {
		dev_err(&client->dev, "failed to check HW configuration: %d",
			ret);
		return ret;
	}

	v4l2_i2c_subdev_init(&s5k2xx->sd, client, &s5k2xx_subdev_ops);

	s5k2xx_power_on(&client->dev);

	ret = s5k2xx_identify_module(s5k2xx);
	if (ret) {
		dev_err(&client->dev, "failed to find sensor: %d", ret);
		goto power_off;
	}

	mutex_init(&s5k2xx->lock);
	s5k2xx->cur_mode = &s5k2xx->data->modes[0];
	ret = s5k2xx_init_controls(s5k2xx);
	if (ret) {
		dev_err(&client->dev, "failed to init controls: %d", ret);
		goto probe_error_v4l2_ctrl_handler_free;
	}

	snprintf(s5k2xx->sd.name, sizeof(s5k2xx->sd.name),
			"%s %s", s5k2xx->data->name, dev_name(&client->dev));

	s5k2xx->sd.internal_ops = &s5k2xx_internal_ops;
	s5k2xx->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
	s5k2xx->sd.entity.ops = &s5k2xx_subdev_entity_ops;
	s5k2xx->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
	s5k2xx->pad.flags = MEDIA_PAD_FL_SOURCE;
	ret = media_entity_pads_init(&s5k2xx->sd.entity, 1, &s5k2xx->pad);
	if (ret) {
		dev_err(&client->dev, "failed to init entity pads: %d", ret);
		goto probe_error_v4l2_ctrl_handler_free;
	}

	ret = v4l2_async_register_subdev_sensor_common(&s5k2xx->sd);
	if (ret < 0) {
		dev_err(&client->dev, "failed to register V4L2 subdev: %d",
			ret);
		goto probe_error_media_entity_cleanup;
	}

	pm_runtime_set_active(&client->dev);
	pm_runtime_enable(&client->dev);
	pm_runtime_idle(&client->dev);

	return 0;

probe_error_media_entity_cleanup:
	media_entity_cleanup(&s5k2xx->sd.entity);

probe_error_v4l2_ctrl_handler_free:
	v4l2_ctrl_handler_free(s5k2xx->sd.ctrl_handler);
	mutex_destroy(&s5k2xx->lock);

power_off:
	s5k2xx_power_off(&client->dev);

	return ret;
}

static const struct dev_pm_ops s5k2xx_pm_ops = {
	SET_SYSTEM_SLEEP_PM_OPS(s5k2xx_suspend, s5k2xx_resume)
	SET_RUNTIME_PM_OPS(s5k2xx_power_off, s5k2xx_power_on, NULL)
};

static const struct of_device_id s5k2xx_of_match[] = {
	{ .compatible = "samsung,s5k2p6sx", &s5k2p6sx_data },
	{ .compatible = "samsung,s5k2x7sp", &s5k2x7sp_data },
	{ /* sentinel */ }
};
MODULE_DEVICE_TABLE(of, s5k2xx_of_match);

static struct i2c_driver s5k2xx_i2c_driver = {
	.driver = {
		.name = "s5k2xx",
		.pm = &s5k2xx_pm_ops,
		.acpi_match_table = ACPI_PTR(s5k2xx_acpi_ids),
		.of_match_table	= of_match_ptr(s5k2xx_of_match),
	},
	.probe_new = s5k2xx_probe,
	.remove = s5k2xx_remove,
};

module_i2c_driver(s5k2xx_i2c_driver);

MODULE_DESCRIPTION("Samsung S5K2xx sensor driver");
MODULE_LICENSE("GPL v2");
